
# 導入
Now to get started, let's start by diving into the most important question first. What exactly is React.js? Well, the official website tells us, React is a JavaScript library for building user interfaces. And that's a nice sentence, but what exactly does it mean? Well, obviously it's a JavaScript library so we will write JavaScript code. We use React in conjunction with our own JavaScript code, but it is a library that's there to help us build user interfaces. And I might add that it's there to help us build highly interactive user interfaces. You don't necessarily need React if you build a simple webpage on which not a lot of things are happening. But if you're building a more interactive website like the demo project we're about to build, then React.js can be a huge help vastly simplifying the code you have to write. And to show you what I mean, consider this very simple example here. I get this user card where I have this Contact button. And if I click this button, this modal overlay opens up and there I can enter some address and submit it. Now, this is not super fancy, but we have a website with some interaction on it. We have a website where I can open this modal and enter data and submit it. Now on this demo website, nothing's happening to that submitted data. But we do have a website that does support some user interaction that must be interactive and reactive because we must React to button clicks and openness overlay. And even though that's a pretty simple example and a simple website here. The JavaScript code, we could write to make this website work this way and to make the website behave that way when not using React.js could look like this. And whilst this is of course not too much code, it's quite a bit of code for this simple interaction. And it's probably easy to imagine that if we had a more complex website with more user interactions on it, we would need to write a lot more code. And of course, therefore we would introduce more potential error sources. Now, when building the exact same application with React.js, the code suddenly looks like this combined with this. And whilst this is still some code, it's a bit more readable and easier to manage. And as soon as you know React, which you will do by the end of the video, it's also much easier to read as you will see. Because even though you don't know React yet, you can clearly see that we seem to be writing some JavaScript code where we have some HTML code blended into that JavaScript code. And we then have clear instructions like setShowModal which seems to do something which then leads to that Modal being shown conditionally. And again, I will teach you all that code and React syntax and all these React features step by step throughout this video. You don't need to understand them yet, but you can probably see that we have some clear instructions here, and some clean code, and most importantly, some HTML code blended into the JavaScript code which is a feature that's supported by React and by the React projects we'll be working in, as you will also learn in this video. In case of the raw Vanilla JavaScript code, we just had step by step instructions where we tell the browser step by step what should happen on the screen, that we want to add an event listener, that we wanna create a new HTML element, how it should be configured, where it should be added, and much more. We have step by step instructions. And indeed we call this approach of writing code the imperative approach where we have step by step instructions simply describing step by step what the browser should do. On the other hand, when using React.js, a major benefit of doing so is that we're able to write declarative code where we write the code for the UI that should be output on the screen, and we blend some syntax like event listeners or dynamic values into that HTML code, and combine it with extra React features where we can, for example, define different states and under which circumstances these different states should be active. And React.js will then generate the appropriate instructions for the browser under the hood so that as a developer, we don't have to write these step by step instructions. And that is indeed one of the major benefits highlighted on the React.js website as well, the fact that you write the declarative code when working with React. Now again, this is just a simple example with a lot of code we don't know yet, but that's one of the major advantages of using React. We often can write much simpler code and therefore actually build way more powerful user interfaces.

So let's get started with React, then. And to get started, we first of all must create a React project. Now, when working with Vanilla JavaScript creating a project is as simple as creating a new folder, and adding a bunch of HTML, JavaScript, and CSS files in there. Now, when building a React web application, a React website, it's not that simple. Instead, you need a project that performs various behind the scenes code transformations automatically. And, you typically also want to have a nice developer experience where the React app you're working on is previewed and automatically updated whenever you change the React code. Now, the behind the scenes code transformations are needed because, as I mentioned before already, when building React apps you typically blend HTML and JavaScript code in one of the same JavaScript file. Now, technically this is not valid JavaScript code, though. The browser would not be able to execute this code, and we will of course learn why we're blending the code like this in just a second. But it is important to understand right now already that this code would not run like this in the browser. That's why it must be transformed, compiled, you could say, to some valid client side JavaScript code that's supported by the browser first, so that we as a developer have the convenience of mixing HTML and JavaScript code. And as an output, we still get code that's supported by the browser. And that's why we need a project set-up that comes with some built-in tools that give us this live preview with the order reloading up on code changes, and where we also get our code transformed under the hood, so that once we're done building our reactive we get a website that can be deployed on some hosting providers, and that can then be visited and be viewed correctly by visitors from all over the world.

So we need a project set up that supports these requirements. And a popular tool for creating such projects that comes with all these features and tools that we need built in is Create React App. This is a tool which you can use to, well, as the name suggest, create React apps that give you this auto reloading and that supports this HTML with JavaScript Syntax. An alternative tool which you could use is Vite, which can also be used to create new React projects. And you can simply follow the instructions shared on these websites of Create React App or Vite to create valid new React projects. Now, for both tools, and also to successfully then run the projects created by those tools you must have Node.js installed on your system. Now, you don't need to be able to write Node.js code. You don't need to know Node.js, but Node.js is used under the hood by those tools that create the projects and then also by the projects and their built in-tools as well. So make sure you have Node.js installed on your system. You can typically download the latest version of Node.js or use the latest LTS version, the latest long-term stability version. And once you got it installed you can create those new projects with "npx create-react-app" to use that tool. Or by running "npm create vite" to use that Vite tool. And I'll do that, but you can use either of the two approaches. Now, once you run these commands, you are typically asked to choose a project name. And here I'll just name it "react-crash-course", but the name is up to you. And then in Vite's case, pick a template, where I'll pick "React". And then JavaScript. And this now creates a new project. Now, once that was done, you can open that newly created project with an editor of your choice. In my case, I'm using Visual Studio Code. And you can start working on that code there. Now, if you use Vite, you also must open the terminal first and navigate into this folder. And for that here I'm using the built-in terminal in VS code, which is already navigated into that folder by default And run "npm install" to install any extra third party packages that are needed to build and run and preview your React application. Once that's done, you can run "npm start" when using a project created with Create React App. And "npm run dev" when using Vite, which I do here. And then you can visit the website on this address, which should be output in the terminal to preview your React app. And the exact output on this screen here might change over time, but you now have a basic React project which we'll now use to learn React. As a side note, attached you also find a link to a project snapshot, which I prepared, which was created with help of Vite, and which I also cleaned up a little bit so that we can all start with the same starting state. So feel free to also look into this starting snapshot and use that starting snapshot to follow along.

So here I am now in my brand new project which I created using that starting snapshot, which was also attached to the last lecture. So that you can simply download that starting snapshot which was created with help of Vite, and which I simply cleaned up a little bit so that we only have a few files in there. And this is now the starting snapshot we'll use to dive into React and learn about these React essentials. Now to briefly get you started with the project we have here. A project created with Vite in this case. In the end, what I do have here is an index HTML file which isn't too important for us here because we won't add any code to that. Instead, we will work in the source folder where we have some .jsx files. And in the end these are JavaScript files that also support HTML code inside of them. This special syntax, which I mentioned which is not supported by browsers, but which is transformed under the hood by the project setup we have here into code that is supported by browsers. This syntax of having HTML in JavaScript is called JSX, and that's why these files have these special JSX extensions. But again, this is not supported by the browser, this is transformed under the hood instead. What's also worth noting, is that I have a CSS file here with some basic CSS styles and this file is also being imported here into a JavaScript file in the end. Normally this would also not work in the browser but this is a never feature supported by this project which is then transformed under the hood. And you can kind of see what it's being transformed to by opening up the developer tools in your browser for this starting snapshot website. And there in the head section you, for example, see that a bunch of scripts and styles were injected. For example, the styles that were defined in this extra CSS file. So this project setup and some tools that were installed as part of this project setup simply detected this CSS import, and therefore included this CSS code in the final website that's being loaded. You also see that, a JavaScript file is being loaded here which if you take a look at it upon loading this website, in the end contains the transformed JavaScript code where you no longer see HTML code as part of the application, but where you instead have some raw optimized JavaScript code, which in the end is responsible for outputting on the screen what we see here. So that's what we got. That's what we'll start with. That's this special JSS syntax which will become important when working with React. And with all of that out of the way, let's now take a closer look at the code we have in these two JSX files, because there we have some strange code which clearly seems to be responsible for outputting Hello World, but it probably makes sense to understand how these different code pieces work together and what's happening here.

So, what's happening in these two JSX files? Sure, we have this HTML code in there, which is called JSX, as you learned, but what exactly is this code doing here? Well, let's start with main.jsx. I can tell you that this is the main entry file of the entire application. The code in this file is executed first when this website is being loaded in the browser. But what's this code doing? Well, we're importing some things from React libraries. This is, in the end, the modern JavaScript import syntax which is also supported by this React project we created here. And we are importing some features from the React library and from the React DOM Library. Now these libraries are installed in this project with help of this package.json file. If you take a look at this package.json file under dependencies you find React and React DOM. Now package.json is a file that's used by Node.js for managing the dependencies of your project, the third-party packages you want to use in your project. And it's also commonly used by front-end projects where you don't build Node.js applications, for managing the packages of those projects as well. So therefore, this project, which we have here, which I created with help of Vite but it would be the same with Create React App, uses the package.json file to define external dependencies, to define which third-party packages will be used in your code. And here we're using React and React DOM, which are simply two separate libraries created by the same team. And these two libraries together form React, the React Library you could say. It's simply a combination of two packages. Now in main.jsx, it all starts with this React DOM thing because there we call the createRoot method. This method takes a pointer at an element in our HTML code. And this is indeed regular, vanilla JavaScript code here. Document get element by ID is not React specific. And what this code does is it reaches out to this element here, which has the ID root in this single HTML file that we have in this project. It's the only HTML file in the entire project. So this code here, in main.jsx, reaches out to that root, to this DIV with ID root and then it calls the render method, in the end, on this object returned by createRoot. It calls the render method, which is a method provided by React, by that React DOM part of React, to be precise. And we then do this. We then pass some JSX code to render. And in the end this simply tells React that inside this DIV with ID root, or in general the element with ID root, this React code should be rendered. So, should be displayed on the screen. Now this strict mode thing here is a special feature offered by React, which is simply enabled some extra checks warning us of potentially suboptimal code we could be writing. Also in regards to future changes that might be added by React where it wants to warn us if we write slightly outdated code or anything like that. The more important part is this app thing here, because this is actually also being imported. This import, where we import app from ./app, that in the end gives us an app thing, an app element as it seems, which is then rendered here with help of this JSX feature. So, by using it like a HTML element in our JavaScript file. Now, ./app simply refers to the app.jsx file. For JavaScript and JSX files you can and should omit the file extension here in your import statements and therefore this refers to app.jsx. And in there we are exporting a function called app. That function is a very simple function. All it does is it returns more JSX code, it returns the H1 HTML element with a text of "Hello World" inside of it. Now this is a so-called React component. And React is all about components. When you build React apps you, in the end, build components and components are simply functions that return JSX code. That's not entirely true. Theoretically there are a few other things they could return as well, but typically they return JSX code. So functions that return JSX code are React components. And React components can be used in other JSX code. That's why this app Function, as we just learned, which is imported in main.jsx, can be used like a HTML element in this JSX code, which is passed to render. Because render wants, in the end, some HTML code, some JSX code to be precise, that it should output on the screen, and we can use our own component, the app component, as part of that JSX code. Now, our own component, the app component, returns this H1 element, and therefore ultimately it's basically this H1 element which is passed to render, between those strict mode tags, which we can ignore. And that's why we see "Hello World" on the screen here. The content of this app component, which we have here. And I am aware that these are a couple of new concepts, JSX components, definitely some new stuff here, but they are also amongst the most important concepts React has to offer. Because React is all about you writing your own components, so your own functions that return HTML code in the end, and using these different components for then composing a more complex user interface. Because components are a key building block when working with React. Ultimately, any website you think of can be split up into different building blocks that make up the website, like a header at the top, a sidebar on the left, and so on. And with React you simply build these individual building blocks as functions that return JSX code. And by combining these building blocks and potentially nesting them into each other you can build complex user interfaces in a granular, easy to manage way. Now, it's not the only important feature added by React, but it's a key feature nonetheless, and they offer as a next step we'll start building our first custom component together, instead of just working with these predefined ones.

So let's get started writing our first custom React code by building our first custom component. As mentioned, components are these functions that return JSX code and as a React developer you'll write dozens, and hundreds, and thousands of those components to build up your React applications. Now we're about to build a Twitter-like demo application where random people can post their stuff for the entire world to read it, amazing. And along the way, whilst building that application, that demo website, we'll dive into many core React features. And we'll get started now by building our first custom component. Now for this demo application which we're about to build, there are actually multiple possible components we could identify. We could, for example, build this button as a separate component. Or this list of posts of tweets, if you wanna call it like this. Or the individual tweets. And indeed, that is how you should think of components and React applications. We have all these building blocks, and we then build the overall UI by combining them. Now, of course, you don't have to put every single character into its own component but it makes sense to group related functionalities together into different building blocks. And here we could, for example, start by taking a closer look at the individual posts. And the first custom component, which I wanna build together with you, therefore, is a component for such a single post. And later, we'll be able to then output multiple posts based on that custom component. Now therefore, back in this project, which I gave you, I'll go to that source folder and in there add a new folder called components. Now this name is up to you. You don't have to name this folder, components. You don't even have to create a folder in the first place, but it makes sense to group your component files together into such a folder. Now this app JSX file, which technically also contains that component, is not part of that folder because that will soon be our root component. And I'll get back to the concept of our root component later. So for the moment, let's go to components. And in there I'll add a new file called post.jsx. The name is of course up to you, but post makes sense, since we're about to add the code that defines a single post in there. The markup that defines a single post, for example, and the .jsx is required because we plan on writing of JSX code in there. If we had just .js that would work in projects created with create React app, but Vite projects actually want .jsx to support JSX code in JavaScript files. And now as a next step, we have to create a function. Because React components are just functions. It's as simple as that regular JavaScript functions with one special gotcha though, the name of your functions should start with an uppercase character. And, of course, the name also should describe what this component will be about. So here I plan on defining the markup that defines an individual post in that grid of posts. And therefore, I'll name the function post like this. And the upper-case starting character is important, it's not required technically in here but it is a recommendation, and it will be required later. Now, this function should be exported so that it can be used in our code files as well. And for that, you can use the standard modern JavaScript export syntax, where you either export it like this by adding the export keyword in front of the function or as a file default. And the only difference is then regarding how you import that function in another file. So here I export it as a default. And now in that function, as mentioned before, we should return some JSX code, because that is what turns a regular function into a React component. It's really only the fact that you start with an upper-case character and even more important that you return some JSX code. Now for a single post to get started here, we could return a div, and then in there may be a paragraph where we output the name of the author of the post. And below that another paragraph with the post body like React.js is awesome. Now, after hitting my auto format shortcut here in VS code, I get this function and that is now indeed our first custom React component. But, of course, if we just add this file like this, and save all changes, nothing changes on the screen. And by the way, you must make sure to keep that NPM run dev process here up and running. In case of a create React app project, it was NPM start with vite its NPM run dev, and this starts a development server which watches your code files, serves your website on the address that's being output here in the terminal, in my case, local host 5173 so that you can preview your React website there as you are building it. And it will automatically reload the website here and update the website and update what you see on the screen as you make and save changes to your code. So that's why this process must keep up and running. But with that, we still don't see our post content here. We still see, Hello World. The reason for that is that I created this component, this post component in a separate file but I'm not using it anywhere. It's the same as with a regular JavaScript function. If I add a function called, add, where I do something, even if I export that function it's still not getting used anywhere. Instead, exporting is just the first step to make it usable outside of this file. But we then have to use the function outside of this file. And it's the same with this component function. Now the place where we want to use our component functions is inside of JSX code of other components. So you build your complex user interfaces by combining components with each other and nesting components into each other. Now at the moment we have two places where we do have some JSX code in use. That's the main JSX file where we pass some JSX code to render and app JSX where I return, Hello World. Now in both places we could output our post component, but typically, when building React user interfaces, you have one root component. So one single component that's being output in main JSX and in this case, that would be the app component here. And then inside of that component, inside of the app component in this case, and any components used by that component, you use your other components. So the post component should be used in the JSX code of the app component. So there, instead of outputting Hello World, we could output post like this. Now in order to use it, we have to import that component function though and we do that by using the import keyword and then post from ./components/Post. And the file extension should be omitted, as mentioned. But you have to specify the full relative path from app JSX to that post .jsx file. So with that, we're importing this post component function and even though it's a function, we're not using it like you would normally use functions by executing it, but instead, we're using it like an HTML element, in this JSX code that's returned by app. In this case, it's the only element that's returned. And that's the special thing about your component functions. They are standard JavaScript functions but you can use them in JSX code and behind the scenes React will basically execute your component functions for you. Take a look at the html Vite JSX code to be precise, that's returned by them. And then build the overall user interface and render it to the screen. That's what React is doing for you. So React is then generating the browser instructions that are needed to bring your HTML code to life in the browser. Now what's really important is that, in the place where you use a component function in JSX code, like we're doing it here with post or in main JSX with app, your component functions must start with an uppercase character. It's optional in the file where you define them, but there you typically also start their names with an uppercase character. But it's absolutely required in the places where you use your components. So in app JSX where I import post from the post JSX file, this name here post must start with an uppercase character. It should not start with a lowercase character because in the JSX code you add to your components elements that start with a lowercase character are considered to be default elements. So React will try to find a default HTML element with that name, which it would not find in case of post. And elements starting with the uppercase character are considered to be custom components. And in that case, React will go ahead and execute your custom component function as mentioned before. But that's why default elements like div are written like this and do not start with an upper-case character, but your own components must start with an upper-case character when using them in JSX. And that's really an important rule to memorize. But with all of that out of the way, if we save everything, we get this content on the screen. And this is now the content we defined in our own post component here. So even though it's not super fancy and definitely not interactive in any way, it is our first custom component defined and used in our React project.

So we got our first custom component here, and it won't be the last component we'll work on. At the moment, it doesn't have any fancy styling, but we'll add some styling soon. But I'd like to make it a bit more dynamic. And for that, I'll start by going to Post.jsx. And then there, outside of the component function, though it doesn't really matter, I'll add a new constant called names, which holds an array of two possible names, Maximilian and Manuel. And I wanna output one of the two names whenever this component is rendered. So basically, whenever I reload the page, and I therefore cause React to re-render the screen, I wanna make sure that React picks one of the two names and outputs it on the screen. So that it's not always Maximilian, but we get some randomness on this website. Now, how could we make this work? Well, in order to make this work, we first of all must add some logic to this component function to pick a random name. So we could add a constant called chosenName. And then here, I wanna call Math.random, this built-in random method that's supported by browsers out of the way. So this is absolutely not React code, this is all built-in instead. And, if what I get here is greater than 0.5, I wanna pick the first name. So names zero, otherwise names one. So with that, I have a 50-50 chance of picking Maximilian or Manuel. Now this, as mentioned here, is standard JavaScript code. And it's important to understand that even though this will be treated as a component by React, it, in the end, still is a function that will be executed by React. And therefore, in this component function, you can in the end run any JavaScript code you want in that function. It's just important that in the end, your function returns some JSX code. So here, I'm picking a random name. And I now wanna output that name here instead of always outputting Maximilian. But, how do we get this chosenName from here to here? Well, for that, we'll use a special syntax that's supported by JSX and React. Instead of hard-coding the value here between these paragraph tags, as we're currently doing it with Maximilian, we add opening and closing curly braces. Single opening and single closing curly braces. And between those curly braces, you can put any JavaScript expression of your choice. Like, for example, two plus two. If you do that and you save that, you'll see that now we get four as a output here. We get four here because when you use this special curly brace syntax in your JSX code, React will go ahead and take whatever is written inside of those curly braces and execute it, and then output the result of that expression that was executed. So in this case, we have two plus two hence the result four is output on the screen. And we can, of course, not just perform mathematical calculations here, but, instead, we can also reference variables or constants. So here I can output chosenName. And instead of outputting the text chosenName now, as it would do without the curly braces, here we get the text, chosenName, with those curly braces, it will instead look into that constant or variable and output the value that's stored in there. So now, we'll get either Maximilian or Manuel. Right now, it's Maximilian for me here, but as I reload this page, you see that it switches between these two names here. And it switches after every reload, because a reload technically restarts the React application, and causes all React components to be re-rendered on the screen. And even though this randomness is not a feature we'll need in the finished application, it is super important to understand how you can output dynamic values in your React applications. Because even though you might not need random values too often, you do very often need the results of calculations of data fetched from some backend API. Something we'll also do later in this course are all kinds of other dynamic values. So this is an important piece of syntax you must keep in mind.

Amazing. We get a component with some dynamic value being output as part of it, and therefore as we reload this app, the names are changing here. As mentioned before it's probably not a feature we'll need all the time, but it's a huge step forward. However, at the moment, we're using this post component just once here in the app component. And that is indeed often the case. You'd find a component and in the entire application you use it only once. For example if you define a separate component for the main header Of the application, the main navigation bar of your website, let's say you typically only have one main navigation bar on the entire website and you'll nonetheless might want to put that into its own component so that all the navigation logic is in one in the same place. But whilst this is a common use case, it's all the very common that you want to reuse a component. And the post component is a perfect example. Why just have one post? We might have multiple posts on our website not just one post. And indeed later we will have multiple posts. Users will be able to create multiple posts, and we want to output a grid filled with all those posts. So how can we output multiple posts based on that one component? Well, that's also quite straightforward In this app component here, let's say we output a main element, and that's a standard HTML element supported by the browser out of the box. And you can tell that it's a standard HTML element by the fact that we start with a lower case character and that we're not importing it from anywhere Because React supports all these standard HTML elements that are supported by browsers out of the box. So I output this main element here and then inside this main element I output my post like before. But I don't just do this once, but instead twice Or three times or four times how often you want. If you do that, you see a bunch of posts here and if you reload you see that they all can have different names. Sometimes you have the same name in all those posts but you have a high chance of having some variation. We do have some maximilians and some manuals here in my case. This also shows us one important feature of components. Even though we use the same component function multiple times, it's in the end executed multiple times by React. So it's not just executed once and the result is then reused but instead it is executed multiple times, once per usage, so to say. That's why we have different names here because the component function was executed multiple times by React. And that's in the end how a component can be reused. You can simply use it multiple times in your JSX code. The same component used multiple times. Now there are a couple of important aspects related to reusing components and I want to start with one important restriction that's the end and forced by React. When you have multiple elements side by side as it's the case here with multiple posts but the same would be true if we had multiple built in components. You must make sure that they're wrapped by another component. Put another words in places where you use JSX code. Like in the return statement here, you are only allowed to return one single element. And that element then in turn might include multiple sibling elements but we would not be allowed to return this JSX code. As you see, I'm already getting an error here. I'm getting an error because in places where you use JSX you must have one root JSX element like this main element here. And then in there you can have as many sibling elements as you'd like to have, but you must have one root element. So that's an important restriction to keep in mind. Now if there is no fitting HTML element that you want to use you can also use empty opening and closing tags. And this syntax will actually be supported by React but you must have one wrapping root element nonetheless. In this case, I'll use the main element though because semantically it makes sense to wrap the main page content into that element. And since we're already talking about JSX and an important restriction enforced by React there is another important rule you must follow. If you have elements that have no content between their opening and closing tags as it's the case for post, you may write them as such. So opening and closing tag without content between but you can also write it as a self-closing tag. You however, are not allowed to write it as a void tag. You see, I'm getting an error here. So you either must add a closing tag or write it as a self-closing tag. And that's true for all elements you're using in your JSX code. No matter if we're talking about custom components or built-in components. If they have no content between the opening and closing tags, they must be self-closing or you must have opening and closing tags. And if you have sibling elements you must wrap them with a root element because you can only return a single element in your component functions. So these are some important things you should keep in mind when working with components, including scenarios where you are reusing your own components.